---
layout: post
title:  投资组合
date:   2024-08-26 11:24:29 +0800
categories: python
---

这篇文章主要分享怎么建立投资组合

套用套件

- yfinance 是 yahoo finance 网络爬虫的套件,作用于下载数据无论是股票还是报表都可以适用

- pandas 数据处理必备套件

- matplotlib 绘图工具

```py
import yfinance as yf
import pandas as pd
import numpy as np
from matplotlib import style
style.use('ggplot')
```

自定义要研究的股票,计算`cov`和`return`

```py
# 定义股票代码
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN']

# 下载股票数据
data = yf.download(tickers, start="2020-01-01", end="2024-01-01")['Adj Close']

# 计算每日收益率
returns = data.pct_change().dropna()

# 查看前几行收益率数据
# print(returns.head())

# 计算协方差矩阵
cov_matrix = returns.cov()

# 打印协方差矩阵
# print(cov_matrix)
```

```py
from scipy.optimize import minimize

# 计算投资组合的年化波动率
def portfolio_volatility(weights, cov_matrix):
    return np.sqrt(np.dot(weights.T, np.dot(cov_matrix * 252, weights)))

# 定义优化目标：最小化波动率
def min_volatility(weights):
    return portfolio_volatility(weights, cov_matrix)

# 初始猜测：假设均匀分配
num_assets = len(tickers)
init_guess = np.array(num_assets * [1. / num_assets])

# 设置权重的边界和约束条件
bounds = tuple((0, 1) for asset in range(num_assets))
constraints = ({'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1})

# 进行优化
optimized = minimize(min_volatility, init_guess, method='SLSQP', bounds=bounds, constraints=constraints)

# 输出优化结果
print("Optimized Weights:", optimized.x)
print("Minimum Volatility:", optimized.fun)
```

```py
# 计算投资组合的预期收益和年化波动率
def portfolio_return(weights, returns):
    return np.sum(returns.mean() * weights) * 252

def portfolio_performance(weights, returns, cov_matrix):
    port_return = portfolio_return(weights, returns)
    port_volatility = portfolio_volatility(weights, cov_matrix)
    return port_return, port_volatility

opt_return, opt_volatility = portfolio_performance(optimized.x, returns, cov_matrix)

print("Expected Portfolio Return:", opt_return)
print("Expected Portfolio Volatility:", opt_volatility)
```

```py
import numpy as np

# 定义蒙特卡洛模拟的次数
num_portfolios = 10000

# 存储结果
results = np.zeros((3, num_portfolios))

for i in range(num_portfolios):
    # 生成随机权重
    weights = np.random.random(len(tickers))
    weights /= np.sum(weights)
    
    # 计算投资组合的收益率和波动率
    port_return = portfolio_return(weights, returns)
    port_volatility = portfolio_volatility(weights, cov_matrix)
    
    # 存储结果
    results[0,i] = port_return
    results[1,i] = port_volatility
    results[2,i] = port_return / port_volatility  # 夏普比率

# 获取最高夏普比率的组合
max_sharpe_idx = np.argmax(results[2])

max_sharpe = results[2,max_sharpe_idx]

sdp, rp = results[1,max_sharpe_idx], results[0,max_sharpe_idx]

# 获取最小波动率的组合
min_vol_idx = np.argmin(results[1])
sdp_min, rp_min = results[1,min_vol_idx], results[0,min_vol_idx]

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 7))
plt.scatter(results[1,:], results[0,:], c=results[2,:], cmap='YlGnBu', marker='x',alpha=0.7)
plt.title('Monte Carlo Simulation of Portfolio Optimization')
plt.xlabel('Volatility')
plt.ylabel('Return')
plt.colorbar(label='Sharpe Ratio')

# 标记最高夏普比率组合和最小波动率组合
plt.scatter(sdp, rp, marker='*', color='r', s=200, label='Maximum Sharpe Ratio')
plt.scatter(sdp_min, rp_min, marker='*', color='g', s=200, label='Minimum Volatility')
plt.legend(labelspacing=0.8)
plt.show()

print(f'returns : {sdp} , volatility : {rp} , sharpe ratio : {max_sharpe}')
```

```py
# 定义无风险利率
risk_free_rate = 0.02

# 计算CAL斜率 (市场投资组合的夏普比率)
slope_cal = (rp - risk_free_rate) / sdp

# 生成CAL数据点
x = np.linspace(0, 0.5, 100)
cal_y = risk_free_rate + slope_cal * x

# 绘制CAL
plt.figure(figsize=(10, 7))
plt.plot(x, cal_y, linestyle='--', color='orange', label='Capital Market Line (CAL)')

plt.scatter(results[1,:], results[0,:], c=results[2,:], cmap='YlGnBu', marker='x',alpha=0.7)
plt.scatter(sdp, rp, marker='*', color='r', s=200, label='Market Portfolio (Max Sharpe)')

plt.title('Capital Market Line (CAL) and Monte Carlo Simulation')
plt.xlabel('Volatility')
plt.ylabel('Return')
# plt.colorbar(label='Sharpe Ratio')
plt.legend(labelspacing=0.8)
plt.show()

# max_sharpe = results[2,max_sharpe_idx]
# print(max_sharpe)
```