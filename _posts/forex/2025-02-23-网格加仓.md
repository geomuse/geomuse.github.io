---
layout: post
title:  forex 网格加仓
date:   2025-02-23 11:01:30 +0800
categories: 
    - forex
---

二、均值回归型补单（网格策略）

适用场景：震荡行情中降低成本

```c
// 示例代码：等差网格补单
int gridLevel = OrdersTotal();
double gridStep = 50*Point; // 50点间隔
if(gridLevel < 5) {
   double lot = 0.1*(gridLevel+1);
   OrderSend(Symbol(),OP_BUY,lot,Ask,3,0,0,"Grid_"+IntegerToString(gridLevel),Magic,0,Blue);
}
```

参数设置：

    网格层数：3-5层

    价格间隔：ATR(14)的1-1.5倍

    单层风险：≤0.5%

关键要点：

    必须设置总止损（如账户5%）

    配合波动率指标过滤

    禁止在单边市使用

以下是一个基于网格交易法的MT4自动加仓脚本，包含详细注释和风险管理功能：

```mql4
//+------------------------------------------------------------------+
//|                                                  GridTrader.mq4 |
//|                                     Copyright 2024, Your Company |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Your Company"
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

//--- 输入参数
input double   InitialLot = 0.1;       // 初始手数
input int      GridStep = 50;          // 网格间距(点)
input int      MaxLayers = 5;          // 最大层数
input int      TakeProfit = 100;       // 止盈点数
input int      StopLoss = 200;         // 整体止损点数
input double   LotMultiplier = 1.5;    // 手数倍增系数

//--- 全局变量
int    magic = 987654;
double gridUpper, gridLower;
bool   firstTrade = true;

//+------------------------------------------------------------------+
//| 初始化函数                                                      |
//+------------------------------------------------------------------+
int OnInit()
{
   // 5位报价平台调整
   int pointMultiplier = 1;
   if(Digits() == 5 || Digits() == 3) pointMultiplier = 10;
   
   GridStep *= pointMultiplier;
   TakeProfit *= pointMultiplier;
   StopLoss *= pointMultiplier;
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| 主交易逻辑                                                      |
//+------------------------------------------------------------------+
void OnTick()
{
   // 首单建立网格
   if(firstTrade && OrdersTotal() == 0)
   {
      double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      if(OrderSend(_Symbol, OP_BUY, InitialLot, price, 3, 0, 0, "Grid_1", magic, 0, clrBlue))
      {
         gridUpper = price + GridStep * _Point;
         gridLower = price - GridStep * _Point;
         firstTrade = false;
      }
      return;
   }

   // 检查已有订单
   if(OrdersTotal() >= MaxLayers) return;
   
   // 获取最新价格
   double lastAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double lastBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   // 网格加仓逻辑
   if(lastAsk >= gridUpper)        // 向上突破网格上沿
   {
      double newLot = NormalizeDouble(InitialLot * MathPow(LotMultiplier, OrdersTotal()), 2);
      if(OrderSend(_Symbol, OP_BUY, newLot, lastAsk, 3, 0, 0, "Grid_"+IntegerToString(OrdersTotal()+1), magic, 0, clrBlue))
      {
         gridUpper += GridStep * _Point;
         gridLower += GridStep * _Point;
      }
   }
   else if(lastBid <= gridLower)   // 向下突破网格下沿
   {
      double newLot = NormalizeDouble(InitialLot * MathPow(LotMultiplier, OrdersTotal()), 2);
      if(OrderSend(_Symbol, OP_SELL, newLot, lastBid, 3, 0, 0, "Grid_"+IntegerToString(OrdersTotal()+1), magic, 0, clrRed))
      {
         gridUpper -= GridStep * _Point;
         gridLower -= GridStep * _Point;
      }
   }

   // 整体止盈止损管理
   ManageExitConditions();
}

//+------------------------------------------------------------------+
//| 平仓管理函数                                                   |
//+------------------------------------------------------------------+
void ManageExitConditions()
{
   double totalProfit = 0;
   double avgPrice = 0;
   double totalLots = 0;
   
   // 计算整体持仓
   for(int i=0; i<OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == magic)
      {
         totalProfit += OrderProfit();
         totalLots += OrderLots();
         avgPrice += OrderOpenPrice() * OrderLots();
      }
   }
   
   if(totalLots > 0) avgPrice /= totalLots;
   
   // 整体止盈
   if(totalProfit >= TakeProfit * _Point * totalLots * MarketInfo(_Symbol, MODE_TICKVALUE))
   {
      CloseAllOrders();
      return;
   }
   
   // 整体止损
   double currentSL = (avgPrice > 0) ? 
                     avgPrice - StopLoss * _Point : 
                     avgPrice + StopLoss * _Point;
                     
   if((avgPrice > 0 && Bid <= currentSL) || (avgPrice < 0 && Ask >= currentSL))
   {
      CloseAllOrders();
   }
}

//+------------------------------------------------------------------+
//| 辅助函数                                                       |
//+------------------------------------------------------------------+
void CloseAllOrders()
{
   for(int i=OrdersTotal()-1; i>=0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == magic)
      {
         double closePrice = (OrderType()==OP_BUY) ? Bid : Ask;
         OrderClose(OrderTicket(), OrderLots(), closePrice, 3, clrWhite);
      }
   }
   firstTrade = true;  // 重置首单标志
}
//+------------------------------------------------------------------+
```

### 策略核心逻辑说明

1. **网格初始化**  
   - 首单建立时同时设置上下网格边界
   - 示例：首单价=1.1000，GridStep=50点(0.0050)
   ```mql4
   gridUpper = 1.1050;  // 首单价 + 50点
   gridLower = 1.0950;  // 首单价 - 50点
   ```

2. **加仓机制**  
   - 价格触及网格边界时自动加仓
   - 手数按倍增系数递增：0.1 → 0.15 → 0.225...
   ```mql4
   newLot = InitialLot * MathPow(LotMultiplier, OrdersTotal())
   ```

3. **动态网格移动**  
   - 每次加仓后整体移动网格区间
   ```mql4
   gridUpper += GridStep * _Point;  // 多单加仓后上移网格
   gridLower += GridStep * _Point;
   ```

4. **整体风控**  
   - 基于平均持仓价格的止损
   - 基于总盈利的止盈
   ```mql4
   // 计算平均持仓价格
   avgPrice = Σ(开仓价*手数) / 总手数
   // 整体止损：平均价±StopLoss
   ```

### 参数配置建议

| 参数名称       | 推荐值  | 说明                          |
|----------------|---------|-------------------------------|
| InitialLot     | 0.1     | 初始手数(根据账户规模调整)    |
| GridStep       | 50      | 推荐50-100点(对应5-10个标准点)|
| LotMultiplier  | 1.2-1.5 | 过高会导致风险指数级增长       |
| TakeProfit     | 100     | 总盈利目标点数                |
| StopLoss       | 200     | 整体止损保护点数              |

### 运行示例（EURUSD多头网格）

1. **首单入场**  
   - 价格：1.1000  
   - 手数：0.1手  
   - 网格区间：[1.0950, 1.1050]

2. **第一次加仓**  
   - 价格上涨至1.1050  
   - 新手数：0.1 × 1.5 = 0.15手  
   - 新网格区间：[1.1000, 1.1100]

3. **第二次加仓**  
   - 价格继续涨至1.1100  
   - 手数：0.15 × 1.5 = 0.225手  
   - 新网格区间：[1.1050, 1.1150]

4. **止盈触发**  
   - 当总盈利达到：(0.1+0.15+0.225)×100点×$10/点 = $47.5  
   - 自动平仓所有订单，重置网格

### 风险提示

1. **网格间距不宜过小**：避免在震荡行情中频繁加仓
2. **慎用高手数倍增**：LotMultiplier>1.5可能造成保证金不足
3. **建议配合**：
   - 最大回撤限制
   - 交易时段过滤
   - 重大数据发布暂停

该脚本适合在趋势明确的行情中使用，建议在主要货币对（如EURUSD、GBPUSD）的欧洲/美国重叠交易时段运行，可结合4小时图或日线图使用。