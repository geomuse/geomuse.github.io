---
layout: post
title:  forex 收盘价动量策略与金字塔加仓法
date:   2025-02-25 11:01:30 +0800
categories: 
   - forex
   - strategy
---

```c
//+------------------------------------------------------------------+
//|                                               MomentumPyramid.mq4 |
//|                        Copyright 2024, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

//--- 输入参数
input int      MagicNumber = 8888;     // 订单魔术码
input double   RiskPercent = 2.0;      // 单笔风险百分比
input int      PyramidLevel = 3;       // 最大加仓层级
input int      MinPoints = 50;         // 加仓间隔点数
input int      BaseSL = 30;            // 基础止损点数
input int      BaseTP = 60;            // 基础止盈点数
input bool     UseTrailing = true;     // 启用移动止损
input int      TrailStart = 50;        // 启动跟踪点数
input int      TrailStep = 20;         // 跟踪步长点数

//+------------------------------------------------------------------+
//| 专家初始化函数                                                  |
//+------------------------------------------------------------------+
int OnInit()
{
   if(Digits() == 5) // 调整5位报价平台参数
   {
      MinPoints *= 10;
      BaseSL *= 10;
      BaseTP *= 10;
      TrailStart *= 10;
      TrailStep *= 10;
   }
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| 核心交易逻辑                                                    |
//+------------------------------------------------------------------+
void OnTick()
{
   // 检查新K线（日线）
   static datetime lastBar;
   if(Time[0] == lastBar) return;
   lastBar = Time[0];
   
   // 获取当前仓位信息
   int totalOrders = CountOrders();
   double avgPrice = CalculateAveragePrice();
   
   // 动量条件判断
   bool buySignal = CheckBuyCondition();
   bool sellSignal = CheckSellCondition();
   
   // 金字塔加仓逻辑
   if(totalOrders < PyramidLevel)
   {
      // 做多条件
      if(buySignal && (totalOrders == 0 || (avgPrice > 0 && Bid > avgPrice + MinPoints*Point)))
      {
         double lot = CalculateLotSize(totalOrders);
         OpenOrder(OP_BUY, lot);
      }
      
      // 做空条件
      if(sellSignal && (totalOrders == 0 || (avgPrice > 0 && Ask < avgPrice - MinPoints*Point)))
      {
         double lot = CalculateLotSize(totalOrders);
         OpenOrder(OP_SELL, lot);
      }
   }
   
   // 移动止损管理
   if(UseTrailing) TrailingStop();
}

//+------------------------------------------------------------------+
//| 动量条件检测函数                                                 |
//+------------------------------------------------------------------+
bool CheckBuyCondition()
{
   // 连续3日收阳线
   if(Close[1] > Open[1] && Close[2] > Open[2] && Close[3] > Open[3])
   {
      // 趋势过滤（价格在200EMA上方）
      if(Close[1] > iMA(NULL, PERIOD_D1, 200, 0, MODE_EMA, PRICE_CLOSE, 1))
         return true;
   }
   return false;
}

bool CheckSellCondition()
{
   // 连续3日收阴线
   if(Close[1] < Open[1] && Close[2] < Open[2] && Close[3] < Open[3])
   {
      // 趋势过滤（价格在200EMA下方）
      if(Close[1] < iMA(NULL, PERIOD_D1, 200, 0, MODE_EMA, PRICE_CLOSE, 1))
         return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| 仓位计算模块                                                    |
//+------------------------------------------------------------------+
double CalculateLotSize(int currentLevel)
{
   double riskAmount = AccountFreeMargin() * RiskPercent / 100;
   double pointValue = MarketInfo(Symbol(), MODE_TICKVALUE);
   double minLot = MarketInfo(Symbol(), MODE_MINLOT);
   
   // 金字塔加仓系数（1:0.6:0.36）
   double ratio = MathPow(0.6, currentLevel);
   double lot = (riskAmount / (BaseSL * pointValue)) * ratio;
   
   return MathMax(minLot, NormalizeDouble(lot, 2));
}

//+------------------------------------------------------------------+
//| 订单管理模块                                                    |
//+------------------------------------------------------------------+
void OpenOrder(int type, double lot)
{
   double sl = (type == OP_BUY) ? Bid - BaseSL*Point : Ask + BaseSL*Point;
   double tp = (type == OP_BUY) ? Bid + BaseTP*Point : Ask - BaseTP*Point;
   
   OrderSend(Symbol(), type, lot, (type==OP_BUY)?Ask:Bid, 3, sl, tp, 
            "MomentumPyramid", MagicNumber, 0, clrNONE);
}

int CountOrders()
{
   int count = 0;
   for(int i=0; i<OrdersTotal(); i++)
      if(OrderSelect(i, SELECT_BY_POS) 
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            count++;
   return count;
}

double CalculateAveragePrice()
{
   double total = 0;
   double lots = 0;
   for(int i=0; i<OrdersTotal(); i++)
      if(OrderSelect(i, SELECT_BY_POS))
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            total += OrderOpenPrice() * OrderLots();
            lots += OrderLots();
         }
   return (lots > 0) ? total / lots : 0;
}

//+------------------------------------------------------------------+
//| 移动止损模块（增强版）                                          |
//+------------------------------------------------------------------+
void TrailingStop()
{
   for(int i=0; i<OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            double currentProfit = 0;
            if(OrderType() == OP_BUY)
               currentProfit = (Bid - OrderOpenPrice()) / Point;
            else if(OrderType() == OP_SELL)
               currentProfit = (OrderOpenPrice() - Ask) / Point;
            
            if(currentProfit >= TrailStart)
            {
               double newSl = (OrderType() == OP_BUY) 
                             ? Bid - TrailStep*Point 
                             : Ask + TrailStep*Point;
                             
               // 确保止损只向盈利方向移动
               if((OrderType() == OP_BUY && newSl > OrderStopLoss()) ||
                  (OrderType() == OP_SELL && newSl < OrderStopLoss()))
               {
                  OrderModify(OrderTicket(), OrderOpenPrice(), 
                             newSl, OrderTakeProfit(), 0, clrNONE);
               }
            }
         }
      }
   }
}
//+------------------------------------------------------------------+
```