---
layout: post
title:  options pricing 
date:   2024-10-23 11:24:29 +0800
categories: 
    - financial
    - options
---

```py
import numpy as np
from scipy.stats import norm

class black_scholes : 
    def __d1(self,S,K,T,r,q,sigma):
        return (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    def __d2(self,S,K,T,r,q,sigma):
        return self.__d1(S,K,T,r,q,sigma) - sigma * np.sqrt(T)

    def call(self,S,K,T,r,q,sigma):
        d1 , d2 = self.__d1(S,K,T,r,q,sigma) , self.__d2(S,K,T,r,q,sigma)
        return S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)

    def put(self,S,K,T,r,q,sigma):
        d1 , d2 = self.__d1(S,K,T,r,q,sigma) , self.__d2(S,K,T,r,q,sigma)
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * np.exp(-q * T) * norm.cdf(-d1)
```

除了`black shcoles model`以外还有其他可以对期权定价的方法

```py
import numpy as np
class binomial_tree_option :

    def put(S, K, T, r, sigma, steps):
        dt = T / steps  # 每一步的时间间隔
        u = np.exp(sigma * np.sqrt(dt))  # 价格上升的比例
        d = 1 / u  # 价格下降的比例
        p = (np.exp(r * dt) - d) / (u - d)  # 风险中性概率

        prices = np.zeros((steps + 1, steps + 1))
        for i in range(steps + 1):
            for j in range(i + 1):
                prices[j, i] = S * (u ** j) * (d ** (i - j))

        option_prices = np.zeros((steps + 1, steps + 1))
        option_prices[:, steps] = np.maximum(K - prices[:, steps], 0)

        for i in range(steps - 1, -1, -1):
            for j in range(i + 1):
                option_prices[j, i] = np.exp(-r * dt) * (p * option_prices[j + 1, i + 1] + (1 - p) * option_prices[j, i + 1])

        return option_prices[0, 0]

    def call(S, K, T, r, sigma, steps):
        dt = T / steps  # 每一步的时间间隔
        u = np.exp(sigma * np.sqrt(dt))  # 价格上升的比例
        d = 1 / u  # 价格下降的比例
        p = (np.exp(r * dt) - d) / (u - d)  # 风险中性概率

        prices = np.zeros((steps + 1, steps + 1))
        for i in range(steps + 1):
            for j in range(i + 1):
                prices[j, i] = S * (u ** j) * (d ** (i - j))

        option_prices = np.zeros((steps + 1, steps + 1))
        option_prices[:, steps] = np.maximum(prices[:, steps] - K, 0)

        for i in range(steps - 1, -1, -1):
            for j in range(i + 1):
                option_prices[j, i] = np.exp(-r * dt) * (p * option_prices[j + 1, i + 1] + (1 - p) * option_prices[j, i + 1])

        return option_prices[0, 0]

# 示例：计算看涨期权价格
S = 100  # 标的资产当前价格
K = 100  # 行权价
T = 1    # 距离到期时间 1 年
r = 0.05 # 无风险利率 5%
sigma = 0.2 # 波动率 20%
steps = 100 # 二叉树步数

call_price = binomial_tree_option().call(S, K, T, r, sigma, steps)
print(f"{call_price}")
```

```py
import numpy as np
class monte_carlo_option_price :
    def call(self,S, K, T, r, sigma, simulations):
        dt = T
        payoffs = np.zeros(simulations)

        # 模拟标的资产价格路径
        for i in range(simulations):
            ST = S * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * np.random.randn())
            payoffs[i] = max(ST - K, 0)

        # 计算期权价格
        option_price = np.exp(-r * T) * np.mean(payoffs)
        return option_price
    
    def put(self,S, K, T, r, sigma, simulations):
        dt = T
        payoffs = np.zeros(simulations)

        # 模拟标的资产价格路径
        for i in range(simulations):
            ST = S * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * np.random.randn())
            payoffs[i] = max(K - ST, 0)

        # 计算期权价格
        option_price = np.exp(-r * T) * np.mean(payoffs)
        return option_price

# 示例：计算看涨期权价格
S = 100  # 标的资产当前价格
K = 100  # 行权价
T = 1    # 距离到期时间 1 年
r = 0.05 # 无风险利率 5%
sigma = 0.2 # 波动率 20%
simulations = 10000 # 模拟次数

call_price = monte_carlo_option_price().call(S, K, T, r, sigma, simulations)
print(f"{call_price}")
```

```py
import numpy as np

# 计算债券价格
def bond_price(face_value, coupon_rate, periods, ytm):
    coupon = face_value * coupon_rate
    price = sum([coupon / (1 + ytm) ** t for t in range(1, periods + 1)]) + face_value / (1 + ytm) ** periods
    return price

# 修正久期计算
def modified_duration(face_value, coupon_rate, periods, ytm, epsilon=1e-4):
    price = bond_price(face_value, coupon_rate, periods, ytm)
    price_up = bond_price(face_value, coupon_rate, periods, ytm + epsilon)
    price_down = bond_price(face_value, coupon_rate, periods, ytm - epsilon)
    
    duration = (price_down - price_up) / (2 * price * epsilon)
    return duration

# 凸性计算
def convexity(face_value, coupon_rate, periods, ytm, epsilon=1e-4):
    price = bond_price(face_value, coupon_rate, periods, ytm)
    price_up = bond_price(face_value, coupon_rate, periods, ytm + epsilon)
    price_down = bond_price(face_value, coupon_rate, periods, ytm - epsilon)
    
    convexity = (price_up + price_down - 2 * price) / (price * epsilon ** 2)
    return convexity

# DV01 计算
def dv01(face_value, coupon_rate, periods, ytm, epsilon=1e-4):
    price = bond_price(face_value, coupon_rate, periods, ytm)
    price_up = bond_price(face_value, coupon_rate, periods, ytm + epsilon)
    
    dv01 = (price - price_up) / 0.0001  # 1 个基点（0.01%）
    return dv01

# 示例参数
face_value = 1000  # 债券面值
coupon_rate = 0.05  # 票息率 5%
periods = 10  # 债券期限 10 年
ytm = 0.04  # 收益率 4%

# 计算结果
duration = modified_duration(face_value, coupon_rate, periods, ytm)
convex = convexity(face_value, coupon_rate, periods, ytm)
dv01_value = dv01(face_value, coupon_rate, periods, ytm)

print(f"修正久期（Duration）：{duration}")
print(f"凸性（Convexity）：{convex}")
print(f"DV01（01的美元价值）：{dv01_value}")
```