---
layout: post
title:  bond pricing 
date:   2024-10-22 11:24:29 +0800
categories: 
    - financial
    - bond
---

<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

```py
def compound_interest_rate(coupon_rate,m,r,face_value):
    coupon_rate = coupon_rate * face_value / m
    years_to_maturity = np.array([0.5,1,1.5,2])
    return (coupon_rate * (1+r/m) ** (-m*years_to_maturity)).sum() \
    + face_value * (1+r/m) ** (-m*years_to_maturity[-1])    
```

```py
def exponential_interest_rate(coupon_rate,r,face_value):
    """
    因此，票面利率为 5% 的债券，
    在连续复利和离散复利下，票面利率的名义值都是 5%。
    但离散复利会将其分成 2.5% 的半年利息，而连续复利则不对票面利率进行分割。
    """
    coupon_rate = coupon_rate * face_value
    years_to_maturity = np.array([0.5,1,1.5,2])
    return coupon_rate * np.exp(-r*years_to_maturity).sum() \
    + face_value*np.exp(-r*years_to_maturity[-1])
```

```py
if __name__ == '__main__':
    print(exponential_interest_rate(3/100,6.76/100,100))
    print(compound_interest_rate(6/100,2,6.76/100,100))
```

还没整理.

```py
import numpy as np
from scipy.stats import norm

# Black-Scholes 期权定价公式
def black_scholes(S, K, T, r, sigma, option_type="call"):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type == "call":
        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type == "put":
        price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    return price

# 差异法计算 Delta
def delta_fd(S, K, T, r, sigma, option_type="call", epsilon=1e-4):
    price_up = black_scholes(S + epsilon, K, T, r, sigma, option_type)
    price_down = black_scholes(S - epsilon, K, T, r, sigma, option_type)
    delta = (price_up - price_down) / (2 * epsilon)
    return delta

# 差异法计算 Gamma
def gamma_fd(S, K, T, r, sigma, option_type="call", epsilon=1e-4):
    price_up = black_scholes(S + epsilon, K, T, r, sigma, option_type)
    price_down = black_scholes(S - epsilon, K, T, r, sigma, option_type)
    price_current = black_scholes(S, K, T, r, sigma, option_type)
    gamma = (price_up - 2 * price_current + price_down) / (epsilon ** 2)
    return gamma

# 差异法计算 Theta
def theta_fd(S, K, T, r, sigma, option_type="call", epsilon=1e-4):
    price_today = black_scholes(S, K, T, r, sigma, option_type)
    price_tomorrow = black_scholes(S, K, T - epsilon, r, sigma, option_type)
    theta = (price_tomorrow - price_today) / epsilon
    return theta

# 差异法计算 Vega
def vega_fd(S, K, T, r, sigma, option_type="call", epsilon=1e-4):
    price_up = black_scholes(S, K, T, r, sigma + epsilon, option_type)
    price_down = black_scholes(S, K, T, r, sigma - epsilon, option_type)
    vega = (price_up - price_down) / (2 * epsilon)
    return vega

# 参数设置
S = 100    # 标的资产价格
K = 100    # 行权价格
T = 1      # 到期时间
r = 0.05   # 无风险利率
sigma = 0.2  # 波动率

# 计算希腊字母
delta_val = delta_fd(S, K, T, r, sigma, option_type="call")
gamma_val = gamma_fd(S, K, T, r, sigma, option_type="call")
theta_val = theta_fd(S, K, T, r, sigma, option_type="call")
vega_val = vega_fd(S, K, T, r, sigma, option_type="call")

print(f"Delta (差异法): {delta_val}")
print(f"Gamma (差异法): {gamma_val}")
print(f"Theta (差异法): {theta_val}")
print(f"Vega (差异法): {vega_val}")
```